<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何优雅处理前端异常？</title>
      <link href="/2020/11/23/error/"/>
      <url>/2020/11/23/error/</url>
      
        <content type="html"><![CDATA[<h3 id="一、为什么要处理异常"><a href="#一、为什么要处理异常" class="headerlink" title="一、为什么要处理异常"></a>一、为什么要处理异常</h3><p>1.增强用户体验；<br>2.远程定位问题；<br>3.未雨绸缪，及早发现问题；<br>4.无法复现问题，尤其是移动端，机型，系统都是问题；<br>5.完善的前端方案，前端监控系统；</p><h3 id="二、需要处理哪些异常"><a href="#二、需要处理哪些异常" class="headerlink" title="二、需要处理哪些异常"></a>二、需要处理哪些异常</h3><p>对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：</p><ul><li>JS 语法错误、代码异常</li><li>AJAX 请求异常</li><li>静态资源加载异常</li><li>Promise 异常</li><li>Iframe 异常</li><li>跨域 Script error</li><li>崩溃和卡顿</li></ul><h3 id="三、Try-Catch-的误区"><a href="#三、Try-Catch-的误区" class="headerlink" title="三、Try-Catch 的误区"></a>三、Try-Catch 的误区</h3><p><strong>try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。</strong></p><p>1.同步运行时错误</p><pre><code>try {    let name = 'erdang';    console.log(nam);} catch(e) {    console.log('捕获到异常：',e);}</code></pre><p>输出：</p><pre><code>捕获到异常： ReferenceError: nam is not defined    at &lt;anonymous&gt;:3:15</code></pre><p>2.不能捕获到语法错误，我们修改一下代码，删掉一个单引号：</p><pre><code>try {    let name = 'erdang;    console.log(nam);} catch(e) {    console.log('捕获到异常：',e);}</code></pre><p>输出：</p><pre><code>Uncaught SyntaxError: Invalid or unexpected token</code></pre><blockquote><p>不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。</p></blockquote><p>3.异步错误</p><pre><code>try {    setTimeout(() =&gt; {        undefined.map(v =&gt; v);    }, 1000)} catch(e) {    console.log('捕获到异常：',e);}</code></pre><p>我们看看日志：</p><pre><code>Uncaught TypeError: Cannot read property 'map' of undefined    at setTimeout (&lt;anonymous&gt;:3:11)</code></pre><p>并没有捕获到异常，这是需要我们特别注意的地方。</p><h3 id="四、window-onerror-不是万能的"><a href="#四、window-onerror-不是万能的" class="headerlink" title="四、window.onerror 不是万能的"></a>四、window.onerror 不是万能的</h3><p>当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。</p><pre><code>/*** @param {String}  message    错误信息* @param {String}  source    出错文件* @param {Number}  lineno    行号* @param {Number}  colno    列号* @param {Object}  error  Error对象（对象）*/window.onerror = function(message, source, lineno, colno, error) {    console.log('捕获到异常：',{message, source, lineno, colno, error});}</code></pre><p>1.首先试试同步运行时错误</p><pre><code>    window.onerror = function(message, source, lineno, colno, error) {    // message：错误信息（字符串）。    // source：发生错误的脚本URL（字符串）    // lineno：发生错误的行号（数字）    // colno：发生错误的列号（数字）    // error：Error对象（对象）    console.log('捕获到异常：',{message, source, lineno, colno, error});}erdang;</code></pre><p>可以看到，我们捕获到了异常：<br><img src="/2020/11/23/error/895EB798-4956-45DE-BDA9-0B3B7BCF4688.png" alt="图一"></p><p>2.再试试语法错误呢？</p><pre><code>window.onerror = function(message, source, lineno, colno, error) {    console.log('捕获到异常：',{message, source, lineno, colno, error});}let name = 'erdang</code></pre><blockquote><p>什么，竟然没有捕获到语法错误？</p></blockquote><p>3.我们最后来试试异步运行时错误：</p><pre><code>window.onerror = function(message, source, lineno, colno, error) {    console.log('捕获到异常：',{message, source, lineno, colno, error});}setTimeout(() =&gt; {    erdang;});</code></pre><p>控制台输出了：</p><pre><code>捕获到异常： {message: "Uncaught ReferenceError: erdang is not defined", source: "http://127.0.0.1:8001/", lineno: 36, colno: 5, error: ReferenceError: erdang is not defined    at setTimeout (http://127.0.0.1:8001/:36:5)}</code></pre><p>4.接着，我们试试网络请求异常的情况：</p><pre><code>&lt;script&gt;window.onerror = function(message, source, lineno, colno, error) {    console.log('捕获到异常：',{message, source, lineno, colno, error});    return true;}&lt;/script&gt;&lt;img src="./erdang.png"&gt;</code></pre><blockquote><p>我们发现，不论是静态资源异常，或者接口异常，错误都无法捕获到,同步异步 都能捕获。</p></blockquote><p>补充一点：window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx</p><pre><code>window.onerror = function(message, source, lineno, colno, error) {    console.log('捕获到异常：',{message, source, lineno, colno, error});    return true;}setTimeout(() =&gt; {    erdang;});</code></pre><p>控制台就不会再有这样的错误了：</p><pre><code>Uncaught ReferenceError: erdang is not defined    at setTimeout ((index):36)</code></pre><p>需要注意：</p><blockquote><p>onerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误；<br>onerror 无法捕获语法错误；</p></blockquote><p>到这里基本就清晰了：在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p><p>问题又来了，捕获不到静态资源加载异常怎么办？</p><p>五、window.addEventListener</p><p>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的onerror() 处理函数。这些 error 事件不会向上冒泡到 window ，不过（至少在 Firefox 中）能被单一的window.addEventListener 捕获。</p><pre><code>&lt;scritp&gt;window.addEventListener('error', (error) =&gt; {    console.log('捕获到异常：', error);}, true)&lt;/script&gt;&lt;img src="./erdang.png"&gt;</code></pre><p><img src="/2020/11/23/error/895EB798-4956-45DE-BDA9-0B3B7BCF4688" alt="图二"></p><p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。</p><p>需要注意：</p><ul><li>不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。</li><li>需要注意避免 addEventListener 重复监听。</li></ul><h3 id="六、Promise-Catch"><a href="#六、Promise-Catch" class="headerlink" title="六、Promise Catch"></a>六、Promise Catch</h3><blockquote><p>在 promise 中使用 catch 可以非常方便的捕获到异步 error ，这个很简单。</p></blockquote><p>没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。</p><p>解决方案： 为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error。使用方式：</p><pre><code>window.addEventListener("unhandledrejection", function(e){    console.log(e);});</code></pre><p>所以，正如我们上面所说，为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。</p><p>补充一点：如果去掉控制台的异常显示，需要加上：</p><p>event.preventDefault();</p><h3 id="七、VUE-errorHandler"><a href="#七、VUE-errorHandler" class="headerlink" title="七、VUE errorHandler"></a>七、VUE errorHandler</h3><pre><code>Vue.config.errorHandler = (err, vm, info) =&gt; {    console.error('通过vue errorHandler捕获的错误');    console.error(err);    console.error(vm);    console.error(info);}</code></pre><h3 id="八、React-异常捕获"><a href="#八、React-异常捕获" class="headerlink" title="八、React 异常捕获"></a>八、React 异常捕获</h3><p>React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息</p><pre><code>componentDidCatch(error, info) {    console.log(error, info);}</code></pre><h3 id="九、iframe-异常"><a href="#九、iframe-异常" class="headerlink" title="九、iframe 异常"></a>九、iframe 异常</h3><p>对于 iframe 的异常捕获，我们还得借力 window.onerror：</p><pre><code>&lt;iframe src="./iframe.html" frameborder="0"&gt;&lt;/iframe&gt;&lt;script&gt;window.frames[0].onerror = function (message, source, lineno, colno, error) {    console.log('捕获到 iframe 异常：',{message, source, lineno, colno, error});    return true;};&lt;/script&gt;</code></pre><h3 id="十、Script-error"><a href="#十、Script-error" class="headerlink" title="十、Script error"></a>十、Script error</h3><p>一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：</p><blockquote><p>跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。</p></blockquote><pre><code>&lt;script src="http://erdang.wang/main.js" crossorigin&gt;&lt;/script&gt;</code></pre><p>或者动态去添加 js 脚本</p><pre><code>const script = document.createElement('script');script.crossOrigin = 'anonymous';script.src = url;document.body.appendChild(script);</code></pre><blockquote><p>特别注意，服务器端需要设置：Access-Control-Allow-Origin</p></blockquote><pre class=" language-bash"><code class="language-bash">const originAddEventListener <span class="token operator">=</span> EventTarget.prototype.addEventListener<span class="token punctuation">;</span>EventTarget.prototype.addEventListener <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>type, listener, options<span class="token punctuation">)</span> <span class="token punctuation">{</span>  const wrappedListener <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">..</span>.args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    try <span class="token punctuation">{</span>      <span class="token keyword">return</span> listener.apply<span class="token punctuation">(</span>this, args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    catch <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>      throw err<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> originAddEventListener.call<span class="token punctuation">(</span>this, type, wrappedListener, options<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>简单解释一下：改写了 EventTarget 的 addEventListener 方法；对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果：<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>   const originAddEventListener <span class="token operator">=</span> EventTarget.prototype.addEventListener<span class="token punctuation">;</span>   EventTarget.prototype.addEventListener <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>type, listener, options<span class="token punctuation">)</span> <span class="token punctuation">{</span>+    // 捕获添加事件时的堆栈+    const addStack <span class="token operator">=</span> new Error<span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>Event <span class="token punctuation">(</span>$<span class="token punctuation">{</span>type<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token variable">`</span></span><span class="token punctuation">)</span>.stack<span class="token punctuation">;</span>     const wrappedListener <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">..</span>.args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       try <span class="token punctuation">{</span>         <span class="token keyword">return</span> listener.apply<span class="token punctuation">(</span>this, args<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       catch <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>+        // 异常发生时，扩展堆栈+        err.stack +<span class="token operator">=</span> <span class="token string">'\n'</span> + addStack<span class="token punctuation">;</span>         throw err<span class="token punctuation">;</span>       <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> originAddEventListener.call<span class="token punctuation">(</span>this, type, wrappedListener, options<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="十一、崩溃和卡顿"><a href="#十一、崩溃和卡顿" class="headerlink" title="十一、崩溃和卡顿"></a>十一、崩溃和卡顿</h3><p>卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？</p><pre class=" language-bash"><code class="language-bash">基于Service Worker的崩溃方案随着PWA概念的流行，大家对Service Worker也逐渐熟悉起来。基于以下原因，我们可以使用Service Worker来实现网页崩溃的监控：*1、Service Worker有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker一般情况下不会崩溃；*2、Service Worker生命周期一般比网页还要长，可以用来监控网页的状态；*3、网页可以通过**navigator.serviceWorker.controller.postMessage**API向掌管自己的SW发送消息。基于以上几点，我们可以实现一种基于心跳检测 的监控方案：*P1：网页加载后，通过**postMessage**API每5s给sw发送一个心跳，表示自己在线，sw将在线的网页登记下来，更新登记时间；*P2：网页在beforeunload时，通过**postMessage**API告知sw自己已经正常关闭，sw将登记的网页清除；*P3：如果网页在运行的过程中crash了，sw中的running状态将不会被清除，更新时间停留在崩溃前的最后一次心跳；*P4：Service Worker每10s查看一遍登记中的网页，发现登记时间已经超出了一定时间（比如15s），即可判定该网页crash了。一些简化后的测试代码，供参考：if<span class="token punctuation">(</span>navigator.serviceWorker.controller <span class="token operator">!=</span><span class="token operator">=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> HEARTBEAT_INTERVAL <span class="token operator">=</span> 5 * 1000<span class="token punctuation">;</span>//每5s发一次心跳    <span class="token keyword">let</span> sessionId <span class="token operator">=</span> uuid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> heartbeat <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        navigator.serviceWorker.controller.postMessage<span class="token punctuation">(</span><span class="token punctuation">{</span>            type: <span class="token string">'heartbeat'</span>,            id: sessionId,//本次页面会话唯一的id；            data: <span class="token punctuation">{</span><span class="token punctuation">}</span> //附加信息，如果页面crash，上报的附加数据        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    window.addEventListener<span class="token punctuation">(</span><span class="token string">'beforeunload'</span>,function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        navigator.serviceWorker.controller.postMessage<span class="token punctuation">(</span><span class="token punctuation">{</span>            type: <span class="token string">'unload'</span>,            id: sessionId        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    setInterval<span class="token punctuation">(</span>heartbeat,HEARTBEAT_INTERVAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    heartbeat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>const CHECK_CRASH_INTERVAL <span class="token operator">=</span> 10*1000<span class="token punctuation">;</span> //每10s检查一次const CRASH_THRESHOLD <span class="token operator">=</span> 15 * 1000<span class="token punctuation">;</span> //超过15s没有心跳则认为已经crashconst pages <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">let</span> timer<span class="token keyword">function</span> checkCrash<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    const now <span class="token operator">=</span> Date.now<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> var <span class="token function">id</span> <span class="token keyword">in</span> pages<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">let</span> page <span class="token operator">=</span> pages<span class="token punctuation">[</span>id<span class="token punctuation">]</span>        if<span class="token punctuation">((</span>now-page.t<span class="token punctuation">)</span><span class="token operator">></span>CRASH_THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">{</span>            //上报 crash            delete pages<span class="token punctuation">[</span>id<span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    if<span class="token punctuation">(</span>Object.keys<span class="token punctuation">(</span>pages<span class="token punctuation">)</span>.length <span class="token operator">==</span> 0<span class="token punctuation">)</span> <span class="token punctuation">{</span>        clearInterval<span class="token punctuation">(</span>timer<span class="token punctuation">)</span>        timer <span class="token operator">=</span> null    <span class="token punctuation">}</span><span class="token punctuation">}</span>worker.addEventListener<span class="token punctuation">(</span><span class="token string">'message'</span>, <span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    const data <span class="token operator">=</span> e.data<span class="token punctuation">;</span>    if<span class="token punctuation">(</span>data.type <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'heartbeat'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        pages<span class="token punctuation">[</span>data.id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>            t: Data.now<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        if<span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>            timer <span class="token operator">=</span> setInterval<span class="token punctuation">(</span>function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                checkCrash<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>,CHECK_CRASH_INTERVAL<span class="token punctuation">)</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span>else if<span class="token punctuation">(</span>data.type <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'unload'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        delete pages<span class="token punctuation">[</span>data.id<span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3 id="十二、错误上报"><a href="#十二、错误上报" class="headerlink" title="十二、错误上报"></a>十二、错误上报</h3><p>1.通过 Ajax 发送数据<br>因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。</p><p>2.动态创建 img 标签的形式</p><pre><code>function report(error) {    let reportUrl = 'http://jartto.wang/report';    new Image().src = `${reportUrl}?logs=${error}`;}</code></pre><p>收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力：</p><pre><code>Reporter.send = function(data) {    // 只采集 30%    if(Math.random() &lt; 0.3) {        send(data)      // 上报错误信息    }}</code></pre><h3 id="十三、总结"><a href="#十三、总结" class="headerlink" title="十三、总结"></a>十三、总结</h3><p>1.可疑区域增加 Try-Catch<br>2.全局监控 JS 异常 window.onerror<br>3.全局监控静态资源异常 window.addEventListener<br>4.捕获没有 Catch 的 Promise 异常：unhandledrejection<br>5.VUE errorHandler 和 React componentDidCatch<br>6.监控网页崩溃：window 对象的 load 和 beforeunload<br>7.跨域 crossOrigin 解决</p><p>其实很简单，正如上文所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> error </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇文章搞懂前端路由原理解析和实现方式</title>
      <link href="/2020/11/18/route/"/>
      <url>/2020/11/18/route/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是前端路由"><a href="#什么是前端路由" class="headerlink" title="什么是前端路由"></a>什么是前端路由</h4><p>路由的概念来源于服务端，在服务端中路由描述的是 URL 与处理函数之间的映射关系。</p><p>在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）</p><h4 id="如何实现前端路由"><a href="#如何实现前端路由" class="headerlink" title="如何实现前端路由"></a>如何实现前端路由</h4><p>要实现前端路由，需要解决两个核心问题：<br>如何改变 URL 却不引起页面刷新？<br>如何检测 URL 变化了？<br>下面分别使用 hash 和 history 两种实现方式回答上面的两个核心问题。</p><p>hash 实现</p><p>hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新。</p><p>通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：通过浏览器前进后退改变 URL、通过标签改变 URL、通过window.location改变URL，这几种情况改变 URL 都会触发 hashchange 事件</p><p>history 实现</p><p>history 提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新。</p><p>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或标签改变 URL 不会触发 popstate 事件。</p><p>好在我们可以拦截 pushState/replaceState的调用和标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</p><p>原生JS版前端路由实现</p><p>基于 hash 实现</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>body<span class="token operator">></span>  <span class="token operator">&lt;</span>ul<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span>-- 定义路由 --<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#/home"</span><span class="token operator">></span>home<span class="token operator">&lt;</span>/a<span class="token operator">></span><span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#/about"</span><span class="token operator">></span>about<span class="token operator">&lt;</span>/a<span class="token operator">></span><span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span>-- 渲染路由对应的 UI --<span class="token operator">></span>    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"routeView"</span><span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>  <span class="token operator">&lt;</span>/ul<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span>// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件window.addEventListener<span class="token punctuation">(</span><span class="token string">'DOMContentLoaded'</span>, onLoad<span class="token punctuation">)</span>// 监听路由变化window.addEventListener<span class="token punctuation">(</span><span class="token string">'hashchange'</span>, onHashChange<span class="token punctuation">)</span>// 路由视图var routerView <span class="token operator">=</span> null<span class="token keyword">function</span> onLoad <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  routerView <span class="token operator">=</span> document.querySelector<span class="token punctuation">(</span><span class="token string">'#routeView'</span><span class="token punctuation">)</span>  onHashChange<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>// 路由变化时，根据路由渲染对应 UI<span class="token keyword">function</span> onHashChange <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  switch <span class="token punctuation">(</span>location.hash<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token string">'#/home'</span><span class="token keyword">:</span>      routerView.innerHTML <span class="token operator">=</span> <span class="token string">'Home'</span>      <span class="token keyword">return</span>    <span class="token keyword">case</span> <span class="token string">'#/about'</span><span class="token keyword">:</span>      routerView.innerHTML <span class="token operator">=</span> <span class="token string">'About'</span>      <span class="token keyword">return</span>    default:      <span class="token keyword">return</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>基于history</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>body<span class="token operator">></span>  <span class="token operator">&lt;</span>ul<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">'/home'</span><span class="token operator">></span>home<span class="token operator">&lt;</span>/a<span class="token operator">></span><span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">'/about'</span><span class="token operator">></span>about<span class="token operator">&lt;</span>/a<span class="token operator">></span><span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"routeView"</span><span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span>  <span class="token operator">&lt;</span>/ul<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span>// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件window.addEventListener<span class="token punctuation">(</span><span class="token string">'DOMContentLoaded'</span>, onLoad<span class="token punctuation">)</span>// 监听路由变化window.addEventListener<span class="token punctuation">(</span><span class="token string">'popstate'</span>, onPopState<span class="token punctuation">)</span>// 路由视图var routerView <span class="token operator">=</span> null<span class="token keyword">function</span> onLoad <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  routerView <span class="token operator">=</span> document.querySelector<span class="token punctuation">(</span><span class="token string">'#routeView'</span><span class="token punctuation">)</span>  onPopState<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 拦截  标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，从而实现点击链接更新 URL 和 UI 的效果。  var linkList <span class="token operator">=</span> document.querySelectorAll<span class="token punctuation">(</span><span class="token string">'a[href]'</span><span class="token punctuation">)</span>  linkList.forEach<span class="token punctuation">(</span>el <span class="token operator">=</span><span class="token operator">></span> el.addEventListener<span class="token punctuation">(</span><span class="token string">'click'</span>, <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e.preventDefault<span class="token punctuation">(</span><span class="token punctuation">)</span>    history.pushState<span class="token punctuation">(</span>null, <span class="token string">''</span>, el.getAttribute<span class="token punctuation">(</span><span class="token string">'href'</span><span class="token punctuation">))</span>    onPopState<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">))</span><span class="token punctuation">}</span>// 路由变化时，根据路由渲染对应 UI<span class="token keyword">function</span> onPopState <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  switch <span class="token punctuation">(</span>location.pathname<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token string">'/home'</span><span class="token keyword">:</span>      routerView.innerHTML <span class="token operator">=</span> <span class="token string">'Home'</span>      <span class="token keyword">return</span>    <span class="token keyword">case</span> <span class="token string">'/about'</span><span class="token keyword">:</span>      routerView.innerHTML <span class="token operator">=</span> <span class="token string">'About'</span>      <span class="token keyword">return</span>    default:      <span class="token keyword">return</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> route </category>
          
      </categories>
      
      
        <tags>
            
            <tag> route </tag>
            
            <tag> 路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bash</title>
      <link href="/2020/11/10/bash/"/>
      <url>/2020/11/10/bash/</url>
      
        <content type="html"><![CDATA[<h4 id="学习命令行"><a href="#学习命令行" class="headerlink" title="学习命令行"></a>学习命令行</h4><p><strong>规则</strong></p><p><code>#</code> 代表注释<br><code>\</code> 代表转义字符，可以将特殊符号变成一般字符<br><code>$</code> 代表的是目前这个 Shell 的线程代号，即是所谓的 PID(process ID)，使用<code>echo $$</code>，出现的数字就是 SHELL 的 PID 代码<br><code>?</code> 是一个特殊的变量，代表上一个执行的命令所回传的值。如果成功执行该命令，则会回传一个 0 值，如果执行过程发生错误，就会回传一个非 0 的值</p><p><strong>缩写</strong></p><p>所谓的命令实际上就是单词的缩写，有以下几种常见缩写方式：<br>1、最常见的缩写是取每个单词的首字母</p><pre><code>cd Change Direcroty 切换目录</code></pre><p>2、如果首字母后为<code>h</code>，则保留<code>h</code></p><pre><code>chmod CHange MODe 切换文件权限</code></pre><p>3、 如果只有一个单词，通常取每个音节的首字母</p><pre><code>cp Copy 文件拷贝</code></pre><p>4、取前几个字母作为缩写</p><pre><code>diff DIFFerences 比较文件差异</code></pre><h4 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h4><p><code>tab</code> 一下 提示  二下自动补全<br><code>ctrl-r</code> 搜索命令行历史记录<br><code>ctrl-w</code> 删除你键入的最后一个单词<br><code>ctrl-u</code> 可以删除行内光标所在位置之前的内容<br><code>ctrl-a</code> 可以将光标移至行首<br><code>ctrl-e</code> 可以将光标移至行尾<br><code>ctrl-k</code> 可以删除光标至行尾的所有内容<br><code>ctrl-l</code> 可以清屏<br><code>cd</code>命令可以切换工作路径<br><code>cd .</code> 当前目录<br><code>cd ~</code> 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 ~（例如 ~/.bashrc）<br><code>cd ..</code> 回到上级目录<br><code>cd -</code> 回到前一个工作路径<br><code>pwd</code> 显示当前工作目录的绝对路径<br><code>mkdir a</code> 创建a文件夹<br><code>mkdir -p a/b/c</code> 创建有层级的目录(a/b/c)，需要使用 -p 选项<br><code>rmdir</code> 删除空目录<br><code>rm -r</code> 删除目录及该目录下的所有目录及文件<br><code>rm -rf</code> 强制删除 <code>-f</code><br><code>cp -r a b</code> # 将目录 a 复制到目录 b<br><code>mv a b</code> # 将目录 a 从当前目录移动到目录 b 下,如果没有目录 b，则目录 a 重命名为目录 b</p><p>依次按下 <code>ctrl-a</code>， <code>#</code>， <code>enter</code> 在行首添加 # 把它当做注释再按下回车执行<br><code>uptime</code> 或 <code>w</code> 来查看系统已经运行多长时间<br><code>alias</code> 来创建常用命令的快捷形式。例如：alias ll=’ls -latr’ 创建了一个新的命令别名 ll。<br><code>unalias lm</code> # 取消别名 lm 的设置<br><code>open</code> 可以使用默认方式打开文件<br><code>ls</code>  # 显示该目录下的所有文件 list files，默认不显示以点开头的文件<br><code>ls -a</code> # 显示所有文件，包括隐藏文件<br><code>ls -l</code> # 显示每个文件的详细信息<br><code>ls ./y</code> # 显示指定路径 <code>./y</code> 下的所有文件<br><code>cat</code># 显示文件内容<br><code>code a.txt</code> # 使用 vscode 打开 a.txt 文件</p><p><code>touch a.txt</code> # 创建空文件a.txt，如果a.txt已经有内容，则修改文件最后更新时间<br><code>echo</code># 输出字符串，也可以新建或改写文件<br><code>echo 123</code> # 输入字符串’123’<br><code>echo -e</code> ‘111\n222’ # 输入多行内容，需要使用-e选项<br><code>echo 123 &gt; 1.txt</code> # 将1.txt的内容改写为’123’<br><code>echo abc &gt;&gt; 1.txt</code> # 向1.txt追加内容，则1.txt的内容为’123 \n abc’<br><code>&gt;</code>表示覆盖<br><code>&gt;&gt;</code> 表示累加</p><p><code>whereis cat</code> 搜索该命令的所在路径及帮助文档所在位置<br><code>which cat</code> 搜索该命令的所在路径及可存在的别名<br><code>find  [搜索范围] [搜索条件]</code> 搜索文件,该命令会把所有文件都搜索<br><code>grep [选项] 字符串 文件名</code> 该命令是搜索字符串的命令 -i 忽略大小写<br>-v 排除指定字符串<br><code>man</code> 命令#获取指定命令的帮助<br><code>man ls</code>#查看ls的帮助<br><code>ifconfig</code>  # 显示所有网卡和接口信息<br><code>lsof -i port:80</code> 哪个程序在使用 80 端口？<br><code>wget {url}</code> # 下载文件，可加 –no-check-certificate 忽略 ssl 验证<br><code>curl -sL {url}</code> # 同 wget -qO- {url} 没有 wget 的时候使用<br><code>netstat -a</code> # 列出所有端口<br><code>jobs</code> # 查看所有后台进程（jobs）<br><code>bg</code>   # 查看后台进程，并切换过去<br><code>fg</code> # 切换后台进程到前台<br><code>fg {job}</code> # 切换特定后台进程到前台<br><code>kill {pid}</code>    # 结束进程<br><code>ps</code> # 查看当前会话进程<br><code>sudo vi /etc/host</code>  编辑host</p><p><a href="https://github.com/skywind3000/awesome-cheatsheets/blob/master/languages/bash.sh" target="_blank" rel="noopener">bash速查</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> bash </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈浏览器与node中的事件循环</title>
      <link href="/2020/10/26/loop/"/>
      <url>/2020/10/26/loop/</url>
      
        <content type="html"><![CDATA[<h2 id="浅谈浏览器与node中的事件循环"><a href="#浅谈浏览器与node中的事件循环" class="headerlink" title="浅谈浏览器与node中的事件循环"></a>浅谈浏览器与node中的事件循环</h2><p>  学习node，总结记录一下两者区别</p><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>先从概念说起:</p><ul><li><p>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位)</p></li><li><p>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</p></li></ul><p>举个栗子</p><pre><code>进程就好比一个工厂，它有独立的资源和空间工厂之间是相互独立的线程就是工厂下面的员工一个工厂可以有很多员工员工之间可以共享资源</code></pre><p>进一步</p><pre><code>- 工厂的资源 -&gt; 系统分配的内存（独立的一块内存）- 工厂之间的相互独立 -&gt; 进程之间相互独立- 多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务- 工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成- 工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等)</code></pre><h3 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h3><ul><li>浏览器是多进程的</li><li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li><li>简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。</li></ul><p>在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了 （所以每一个Tab标签对应一个进程并不一定是绝对的）</p><h3 id="浏览器有哪些进程"><a href="#浏览器有哪些进程" class="headerlink" title="浏览器有哪些进程"></a>浏览器有哪些进程</h3><ol><li><p>Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有:</p><ul><li><p>负责浏览器界面显示，与用户交互。如前进，后退等</p></li><li><p>负责各个页面的管理，创建和销毁其他进程</p></li><li><p>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上</p></li><li><p>网络资源的管理，下载等</p></li></ul></li><li><p>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</p></li><li><p>GPU进程：最多一个，用于3D绘制等</p></li><li><p>浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为面渲染，脚本执行，事件处理等</p></li></ol><h3 id="重点：浏览器渲染进程"><a href="#重点：浏览器渲染进程" class="headerlink" title="重点：浏览器渲染进程"></a>重点：浏览器渲染进程</h3><p>1.GUI渲染线程</p><ul><li><p>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</p></li><li><p>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</p></li><li><p>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p></li></ul><p>2.JS引擎线程</p><ul><li><p>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎)</p></li><li><p>JS引擎线程负责解析Javascript脚本，运行代码。</p></li><li><p>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</p></li><li><p>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p></li></ul><p>3.事件触发线程</p><ul><li><p>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</p></li><li><p>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</p></li><li><p>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</p></li><li><p>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</p></li></ul><p>4.定时触发器线程</p><ul><li><p>传说中的setInterval与setTimeout所在线程</p></li><li><p>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确</p></li><li><p>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</p></li><li><p>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</p></li></ul><p>5.异步http请求线程</p><ul><li><p>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</p></li><li><p>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</p></li></ul><p><img src="/2020/10/26/loop/2084336019-5a65972413011_articlex.png" alt="图一"></p><h3 id="WebWorker，JS的多线程"><a href="#WebWorker，JS的多线程" class="headerlink" title="WebWorker，JS的多线程"></a>WebWorker，JS的多线程</h3><ul><li><p>创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</p></li><li><p>JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</p></li></ul><p>如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，<br>只待计算出结果后，将结果通信给主线程即可，perfect!</p><p>JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p><h3 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h3><p>为了简化理解，前期工作直接省略成：(下一篇在记录，输入一个url发生了什么)</p><p>浏览器输入url，浏览器主进程接管，开一个下载线程，<br>然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，<br>随后将内容通过RendererHost接口转交给Renderer进程</p><p>浏览器渲染流程开始</p><p>浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：</p><p>  1.浏览器解析HTML构建DOM树<br>  2.解析CSS 构建render树(讲css代码解析成css树，然后和dom合并成render树)<br>  3.布局render树（Layout/reflow），负责各元素尺寸、位置的计算<br>  4.绘制render树（paint），绘制页面像素信息<br>  5.浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</p><p>  渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了</p><h4 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后</h4><ul><li><p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。<br>(譬如如果有async加载的脚本就不一定完成)</p></li><li><p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。（渲染完毕了）</p></li></ul><p>所以，顺序是：DOMContentLoaded -&gt; load</p><h4 id="css加载是否会阻塞dom树渲染"><a href="#css加载是否会阻塞dom树渲染" class="headerlink" title="css加载是否会阻塞dom树渲染"></a>css加载是否会阻塞dom树渲染</h4><p>css加载不会阻塞DOM树解析,但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</p><h5 id="硬件加速时请使用index"><a href="#硬件加速时请使用index" class="headerlink" title="硬件加速时请使用index"></a>硬件加速时请使用index</h5><p>使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染<br>简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意</p><h3 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h3><p>首先</p><ul><li>JS分为同步任务和异步任务</li><li>同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件</li><li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li></ul><p>上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在,Promise里有了一个一个新的概念：microtask</p><p>进一步，JS中异步队列分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask可称为task,宏任务队列可以有多个，微任务队列只有一个。</p><h4 id="Micro-Task-与-Macro-Task"><a href="#Micro-Task-与-Macro-Task" class="headerlink" title="Micro-Task 与 Macro-Task"></a>Micro-Task 与 Macro-Task</h4><ul><li>macrotask又称之为宏任务,每次执行栈执行的代码就是一个宏任务<ul><li>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染</li></ul></li></ul><p>（<code>task-&gt;渲染-&gt;task-&gt;...</code>）</p><ul><li><p>microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务</p><ul><li>在当前task任务后，下一个task之前，在渲染之前</li><li>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等</li><li>在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）</li></ul></li></ul><h5 id="会形成macrotask和microtask的场景"><a href="#会形成macrotask和microtask的场景" class="headerlink" title="会形成macrotask和microtask的场景"></a>会形成macrotask和microtask的场景</h5><ul><li><p>常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等</p></li><li><p>常见的 micro-task 比如: process.nextTick、new Promise().then(回调)、MutationObserver(html5 新特性) 等。</p><p><strong>异步的实现方式有哪些喃</strong></p><ul><li><p>ES6之前：callback、eventloop</p></li><li><p>ES6：Generator Promise</p></li><li><p>ES7:Async/Await</p><p>Promise中的异步体现在then和catch中，所以写在Promise中的代码是被当做同步任务立即执行的</p><p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体</p><p>await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码。</p></li></ul></li></ul><p>总结下运行机制</p><ul><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li><li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li></ul><p>另外，请注意下Promise的polyfill与官方版本的区别：</p><ul><li>官方版本中，是标准的microtask形式</li><li>polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式<br>请特别注意这两点区别</li></ul><p>注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了），<br>但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准)</p><h3 id="Node-中的-Event-Loop"><a href="#Node-中的-Event-Loop" class="headerlink" title="Node 中的 Event Loop"></a>Node 中的 Event Loop</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js 采用 V8 作为 js 的解析引擎，而 I/O 处理方面使用了自己设计的 libuv，libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 API，事件循环机制也是它里面的实现。<br><img src="/2020/10/26/loop/2019-01-14-004.png" alt="图二"></p><p>Node.js 的运行机制如下:</p><ul><li>V8 引擎解析 JavaScript 脚本。</li><li>解析后的代码，调用 Node API。</li><li>libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。</li><li>V8 引擎再将结果返回给用户。</li></ul><h4 id="六个阶段"><a href="#六个阶段" class="headerlink" title="六个阶段"></a>六个阶段</h4><p>libuv 引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。<br><img src="/2020/10/26/loop/2019-01-14-005.png" alt="图二"></p><p>从上图中，大致看出 node 中的事件循环的顺序：</p><p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O 事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段（按照该顺序反复运行）…</p><ul><li>timers 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调</li><li>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li><li>idle, prepare 阶段：仅 node 内部使用</li><li>poll 阶段：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里</li><li>check 阶段：执行 setImmediate() 的回调</li><li>close callbacks 阶段：执行 socket 的 close 事件回调</li></ul><p>注意：上面六个阶段都不包括 process.nextTick()(下文会介绍)</p><p>我们详细介绍timers、poll、check这 3 个阶段，因为日常开发中的绝大部分异步任务都是在这 3 个阶段处理的。<br><strong>在进入第一次循环之前，会先进行如下操作(会初始化事件循环)</strong></p><ul><li>同步任务</li><li>发出异步请求</li><li>规划定时器生效的时间</li><li>执行process.nextTick()</li></ul><h5 id="1-timer"><a href="#1-timer" class="headerlink" title="1.timer"></a>1.timer</h5><p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。<br>同样，<strong>在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。</strong></p><h5 id="2-poll-轮询"><a href="#2-poll-轮询" class="headerlink" title="2. poll 轮询"></a>2. poll 轮询</h5><p>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p><ul><li>回到 timer 阶段执行回调</li><li>执行 I/O 回调</li></ul><p>并且在进入该阶段时如果没有设定 timer 的话，会发生以下两件事情:</p><ul><li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li><li>如果 poll 队列为空时，会有两件事发生<ul><li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li><li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li></ul></li></ul><p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer ，如果有的话会回到 timer 阶段执行回调。</p><h5 id="3-check-阶段"><a href="#3-check-阶段" class="headerlink" title="3.check 阶段"></a>3.check 阶段</h5><p>setImmediate()的回调会被加入 check 队列中，从 event loop 的阶段图可以知道，check 阶段的执行顺序在 poll 阶段之后</p><pre><code>console.log('start')setTimeout(() =&gt; {  console.log('timer1')  Promise.resolve().then(function() {    console.log('promise1')  })}, 0)setTimeout(() =&gt; {  console.log('timer2')  Promise.resolve().then(function() {    console.log('promise2')  })}, 0)Promise.resolve().then(function() {  console.log('promise3')})console.log('end')//start=&gt;end=&gt;promise3=&gt;timer1=&gt;timer2=&gt;promise1=&gt;promise2</code></pre><ul><li>一开始执行栈的同步任务（这属于宏任务）执行完毕后（依次打印出 start end，并将 2 个 timer 依次放入 timer 队列）,会先去执行微任务（这点跟浏览器端的一样），所以打印出 promise3</li><li>然后进入 timers 阶段，执行 timer1 的回调函数，打印 timer1，并将 promise.then 回调放入 microtask 队列，同样的步骤执行 timer2，打印 timer2；这点跟浏览器端相差比较大，timers 阶段有几个 setTimeout/setInterval 都会依次执行，并不像浏览器端，每执行一个宏任务后就去执行一个微任务（关于 Node 与浏览器的 Event Loop 差异，下文还会详细介绍）。</li></ul><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><h5 id="1-setTimeout-和-setImmediate"><a href="#1-setTimeout-和-setImmediate" class="headerlink" title="1.setTimeout 和 setImmediate"></a>1.setTimeout 和 setImmediate</h5><p>二者非常相似，区别主要在于调用时机不同</p><ul><li><p>setImmediate 设计在 poll 阶段完成时执行，即 check 阶段；</p></li><li><p>setTimeout 设计在 poll 阶段为空闲时，且设定时间到达后执行，但它在 timer 阶段执行</p><pre><code>setTimeout(function timeout () { console.log('timeout');},0);setImmediate(function immediate () { console.log('immediate');});</code></pre></li><li><p>对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。</p></li><li><p>首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的<br>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调</p></li><li><p>如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了</p></li><li><p><em>但当二者在异步 i/o callback 内部调用时，总是先执行 setImmediate，再执行 setTimeout*</em></p><pre><code> const fs = require('fs') fs.readFile(__filename, () =&gt; {   setTimeout(() =&gt; {     console.log('timeout');   }, 0)   setImmediate(() =&gt; {     console.log('immediate')   }) }) // immediate // timeout</code></pre></li></ul><h5 id="2-process-nextTick"><a href="#2-process-nextTick" class="headerlink" title="2.process.nextTick"></a>2.process.nextTick</h5><p>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p><pre><code>setTimeout(() =&gt; {  console.log('timer1')  Promise.resolve().then(function() {  console.log('promise1')  })}, 0)process.nextTick(() =&gt; {    console.log('nextTick')    process.nextTick(() =&gt; {        console.log('nextTick')        process.nextTick(() =&gt; {            console.log('nextTick')                process.nextTick(() =&gt; {                    console.log('nextTick')                })        })    })})// nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>浏览器和 Node 环境下，microtask 任务队列的执行时机不同</p><ul><li>Node 端，microtask 在事件循环的各个阶段之间执行,在各个阶段，当前阶段的宏任务都执行完才会执行当前阶段的微任务</li><li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 事件循环 </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setTimeout 和 setInterval 的区别及相互模拟</title>
      <link href="/2020/10/23/time/"/>
      <url>/2020/10/23/time/</url>
      
        <content type="html"><![CDATA[<p>setTimeout 和 setInterval 的区别及相互模拟<br>最近在复习 node的事件循环和浏览器的事件循环，突然想起setTimeout 和 setInterval 特此记录一下</p><h2 id="一、setTimeout-和-setInterval的区别"><a href="#一、setTimeout-和-setInterval的区别" class="headerlink" title="一、setTimeout 和 setInterval的区别"></a>一、setTimeout 和 setInterval的区别</h2><h3 id="setTimeout-定义和用法"><a href="#setTimeout-定义和用法" class="headerlink" title="setTimeout() 定义和用法"></a>setTimeout() 定义和用法</h3><p>定义：setTimeout()方法用于在指定毫秒数后再调用函数或者计算表达式（以毫秒为单位）返回的 ID 值可用作 清除clearTimeout() 方法的参数<br>语法：</p><pre><code>setTimeout(fn,ms)</code></pre><p>fn：必需，要调用的函数后要执行的函数；ms：必需，在执行代码前需等待的毫秒数。<br>setTimeout() 只执行函数一次，如果需要多次调用可以使用 setInterval()，或者在函数体内再次调用setTimeout()</p><h3 id="setInterval-定义和用法"><a href="#setInterval-定义和用法" class="headerlink" title="setInterval() 定义和用法"></a>setInterval() 定义和用法</h3><p>定义：setInterval() 方法用于按照指定的周期（以毫秒计）来循环调用函数或计算表达式，直到 clearInterval() 被调用或窗口关闭 返回的 ID 值可用作 清除clearTimeout() 方法的参数<br>语法：</p><pre><code>setInterval(fn,ms)</code></pre><p>fn：必需，要调用的函数后要执行的函数；ms：必需，在执行代码前需等待的毫秒数。<br>setInterval() 会不停的调用函数，直到clearInterval() 被调用或者窗口被关闭，由 setInterval() 返回的ID值可用作 clearInterval() 方法的参数。</p><h2 id="二、setInterval缺点"><a href="#二、setInterval缺点" class="headerlink" title="二、setInterval缺点"></a>二、setInterval缺点</h2><p>定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，取决于何时被主线程的事件循环取到，并执行</p><pre><code>setInterval(function, N)  //即：每隔N秒把function事件推到消息队列中</code></pre><p>使用setInterval()的问题在于，定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿</p><p><img src="/2020/10/23/time/31691-20200730104425601-510760599.png" alt="图一"></p><p>上图可见，setInterval每隔100ms往队列中添加一个事件；100ms后，添加T1定时器代码至队列中，主线程中还有任务在执行，所以等待，some event执行结束后执行T1定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行T1代码，所以等待；又过了100ms，理论上又要往队列里推一个定时器代码，但由于此时T2还在队列中，所以T3不会被添加，结果就是此时被跳过；这里我们可以看到，T1定时器执行结束后马上执行了T2代码，所以并没有达到定时器的效果,而是连续执行。</p><p>因此，js引擎对这个问题的解决方法就是，当使用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。</p><p>但是，这样就会导致一些间隔被跳过了，例如上面所讲的，这里依旧有1个间隔被跳过了。如果功能需求是必须要每个定时器的回调函数都有被执行到，这里就不能满足需求了。</p><p>综上所述，setInterval有两个缺点：</p><p>  1.使用setInterval时，某些间隔会被跳过；即使setInterval调用的方法报错了，他仍然会继续执行。<br>  2.无视网络延迟，可能多个定时器会连续执行；</p><p>因而我们一般用 setTimeout 模拟 setInterval，来规避掉上面的缺点。</p><pre><code>setTimeout(function () {  // 任务  setTimeout(arguments.callee, 1000);}, 1000)</code></pre><p>每次函数执行的时候都会创建一个新的定时器。第二个setTimeout()调用当前执行的函数，并为其设置另外一个定时器。这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> setTimeout </tag>
            
            <tag> setInterval </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的节流与去抖</title>
      <link href="/2020/07/22/dene/"/>
      <url>/2020/07/22/dene/</url>
      
        <content type="html"><![CDATA[<p>优化高频率执行js代码的一种手段，js中的一些事件如浏览器的resize、scroll，鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。</p><h3 id="什么是函数节流与函数防抖"><a href="#什么是函数节流与函数防抖" class="headerlink" title="什么是函数节流与函数防抖"></a>什么是函数节流与函数防抖</h3><p>在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。</p><p>通常这种情况下我们怎么去解决的呢？一般来讲，防抖和节流是比较好的解决方案。</p><p>让我们先来看看在事件持续触发的过程中频繁执行函数是怎样的一种情况。</p><p>html 文件中代码如下</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"content"</span> style<span class="token operator">=</span><span class="token string">"height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">let</span> num <span class="token operator">=</span> 1<span class="token punctuation">;</span>    <span class="token keyword">let</span> content <span class="token operator">=</span> document.getElementById<span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        content.innerHTML <span class="token operator">=</span> num++<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    content.onmousemove <span class="token operator">=</span> count<span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>在上述代码中，div 元素绑定了 mousemove 事件，当鼠标在 div（灰色）区域中移动的时候会持续地去触发该事件导致频繁执行函数。效果如下</p><p><img src="/2020/07/22/dene/4842858-652a8eb5c73db0c7.webp" alt="图一"></p><p>可以看到，在没有通过其它操作的情况下，函数被频繁地执行导致页面上数据变化特别快。所以，接下来让我们来看看防抖和节流是如何去解决这个问题的。</p><h4 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h4><p><strong>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</strong></p><p>分解一下</p><ul><li>延迟n秒后执行</li><li>触发重新计时</li><li>为了便于统一管理全局变量采用闭包形式</li></ul><pre class=" language-bash"><code class="language-bash">//延迟n秒执行<span class="token keyword">function</span> debounce<span class="token punctuation">(</span>fn,delay<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>          fn.apply<span class="token punctuation">(</span>this,arguments<span class="token punctuation">)</span>        <span class="token punctuation">}</span>,delay<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>//触发重新计时<span class="token keyword">function</span> debounce<span class="token punctuation">(</span>fn,delay<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> <span class="token function">timeout</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token keyword">return</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>    if<span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>clearTimeout<span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">timeout</span> <span class="token operator">=</span> setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      fn.apply<span class="token punctuation">(</span>this,args<span class="token punctuation">)</span>    <span class="token punctuation">}</span>,delay<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>// 用法var testDebounceFn <span class="token operator">=</span> debounce<span class="token punctuation">(</span>testDebounce, 1000<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h4><p><strong>每隔一段时间，只执行一次函数。</strong><br>一般有两种方式可以实现，分别是时间戳版和定时器版</p><p>分解一下</p><ul><li>持续触发并不会执行多次</li><li>到一定时间再去执行</li><li>为了便于统一管理全局变量采用闭包形式</li></ul><pre class=" language-bash"><code class="language-bash">//定时器版<span class="token keyword">function</span> throttle<span class="token punctuation">(</span>fn,delay<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> <span class="token function">timeout</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token keyword">return</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>    if<span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>return<span class="token punctuation">;</span>    <span class="token function">timeout</span> <span class="token operator">=</span> setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      fn.apply<span class="token punctuation">(</span>this,args<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">timeout</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>,delay<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> throttle<span class="token punctuation">(</span>fn,delay<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> can <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>    if<span class="token punctuation">(</span><span class="token operator">!</span>can<span class="token punctuation">)</span>return<span class="token punctuation">;</span>    can  <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      fn.apply<span class="token punctuation">(</span>this,args<span class="token punctuation">)</span>      can <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>,delay<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>//时间戳版<span class="token keyword">function</span> throttle<span class="token punctuation">(</span>fn,delay<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> previous <span class="token operator">=</span> 0<span class="token punctuation">;</span>  <span class="token keyword">return</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> now <span class="token operator">=</span> new Date<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>    if<span class="token punctuation">(</span>now-prvious<span class="token operator">></span>delay<span class="token punctuation">)</span><span class="token punctuation">{</span>      fn.apply<span class="token punctuation">(</span>this,args<span class="token punctuation">)</span>      previous <span class="token operator">=</span> now<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>相同点：</p><ul><li>都可以通过使用 setTimeout 实现。</li><li>目的都是，降低回调执行频率。节省计算资源。</li></ul><p>不同点：</p><ul><li>函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout 和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能。</li><li>函数防抖关注一定时间连续触发的事件只在最后执行一次，而函数节流侧重于一段时间内只执行一次。</li></ul><p><strong>函数防抖的应用场景</strong><br>连续的事件，只需触发一次回调的场景有：</p><ul><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li><li>手机号、邮箱验证输入检测</li><li>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li></ul><p><strong>函数节流的应用场景</strong><br>间隔一段时间执行一次回调的场景有：</p><ul><li>滚动加载，加载更多或滚到底部监听</li><li>谷歌搜索框，搜索联想功能</li><li>高频点击提交，表单重复提交</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 节流 </tag>
            
            <tag> 去抖 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
