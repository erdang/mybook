<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>setTimeout 和 setInterval 的区别及相互模拟</title>
      <link href="/2020/10/23/time/"/>
      <url>/2020/10/23/time/</url>
      
        <content type="html"><![CDATA[<p>setTimeout 和 setInterval 的区别及相互模拟<br>最近在复习 node的事件循环和浏览器的事件循环，突然想起setTimeout 和 setInterval 特此记录一下</p><h2 id="一、setTimeout-和-setInterval的区别"><a href="#一、setTimeout-和-setInterval的区别" class="headerlink" title="一、setTimeout 和 setInterval的区别"></a>一、setTimeout 和 setInterval的区别</h2><h3 id="setTimeout-定义和用法"><a href="#setTimeout-定义和用法" class="headerlink" title="setTimeout() 定义和用法"></a>setTimeout() 定义和用法</h3><p>定义：setTimeout()方法用于在指定毫秒数后再调用函数或者计算表达式（以毫秒为单位）返回的 ID 值可用作 清除clearTimeout() 方法的参数<br>语法：</p><pre><code>setTimeout(fn,ms)</code></pre><p>fn：必需，要调用的函数后要执行的函数；ms：必需，在执行代码前需等待的毫秒数。<br>setTimeout() 只执行函数一次，如果需要多次调用可以使用 setInterval()，或者在函数体内再次调用setTimeout()</p><h3 id="setInterval-定义和用法"><a href="#setInterval-定义和用法" class="headerlink" title="setInterval() 定义和用法"></a>setInterval() 定义和用法</h3><p>定义：setInterval() 方法用于按照指定的周期（以毫秒计）来循环调用函数或计算表达式，直到 clearInterval() 被调用或窗口关闭 返回的 ID 值可用作 清除clearTimeout() 方法的参数<br>语法：</p><pre><code>setInterval(fn,ms)</code></pre><p>fn：必需，要调用的函数后要执行的函数；ms：必需，在执行代码前需等待的毫秒数。<br>setInterval() 会不停的调用函数，直到clearInterval() 被调用或者窗口被关闭，由 setInterval() 返回的ID值可用作 clearInterval() 方法的参数。</p><h2 id="二、setInterval缺点"><a href="#二、setInterval缺点" class="headerlink" title="二、setInterval缺点"></a>二、setInterval缺点</h2><p>定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，取决于何时被主线程的事件循环取到，并执行</p><pre><code>setInterval(function, N)  //即：每隔N秒把function事件推到消息队列中</code></pre><p>使用setInterval()的问题在于，定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿</p><p><img src="/2020/10/23/time/31691-20200730104425601-510760599.png" alt="图一"></p><p>上图可见，setInterval每隔100ms往队列中添加一个事件；100ms后，添加T1定时器代码至队列中，主线程中还有任务在执行，所以等待，some event执行结束后执行T1定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行T1代码，所以等待；又过了100ms，理论上又要往队列里推一个定时器代码，但由于此时T2还在队列中，所以T3不会被添加，结果就是此时被跳过；这里我们可以看到，T1定时器执行结束后马上执行了T2代码，所以并没有达到定时器的效果,而是连续执行。</p><p>因此，js引擎对这个问题的解决方法就是，当使用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。</p><p>但是，这样就会导致一些间隔被跳过了，例如上面所讲的，这里依旧有1个间隔被跳过了。如果功能需求是必须要每个定时器的回调函数都有被执行到，这里就不能满足需求了。</p><p>综上所述，setInterval有两个缺点：</p><p>  1.使用setInterval时，某些间隔会被跳过；即使setInterval调用的方法报错了，他仍然会继续执行。<br>  2.无视网络延迟，可能多个定时器会连续执行；</p><p>因而我们一般用 setTimeout 模拟 setInterval，来规避掉上面的缺点。</p><pre><code>setTimeout(function () {  // 任务  setTimeout(arguments.callee, 1000);}, 1000)</code></pre><p>每次函数执行的时候都会创建一个新的定时器。第二个setTimeout()调用当前执行的函数，并为其设置另外一个定时器。这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> setTimeout </tag>
            
            <tag> setInterval </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的节流与去抖</title>
      <link href="/2020/07/22/dene/"/>
      <url>/2020/07/22/dene/</url>
      
        <content type="html"><![CDATA[<p>优化高频率执行js代码的一种手段，js中的一些事件如浏览器的resize、scroll，鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。</p><h2 id="什么是函数节流与函数防抖"><a href="#什么是函数节流与函数防抖" class="headerlink" title="什么是函数节流与函数防抖"></a>什么是函数节流与函数防抖</h2><p>在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。</p><p>通常这种情况下我们怎么去解决的呢？一般来讲，防抖和节流是比较好的解决方案。</p><p>让我们先来看看在事件持续触发的过程中频繁执行函数是怎样的一种情况。</p><p>html 文件中代码如下</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"content"</span> style<span class="token operator">=</span><span class="token string">"height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">let</span> num <span class="token operator">=</span> 1<span class="token punctuation">;</span>    <span class="token keyword">let</span> content <span class="token operator">=</span> document.getElementById<span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        content.innerHTML <span class="token operator">=</span> num++<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    content.onmousemove <span class="token operator">=</span> count<span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>在上述代码中，div 元素绑定了 mousemove 事件，当鼠标在 div（灰色）区域中移动的时候会持续地去触发该事件导致频繁执行函数。效果如下<br><img src="/2020/07/22/dene/4842858-652a8eb5c73db0c7.webp" alt="img"></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 节流 </tag>
            
            <tag> 去抖 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
