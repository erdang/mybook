<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅谈浏览器与node中的事件循环</title>
      <link href="/2020/10/26/loop/"/>
      <url>/2020/10/26/loop/</url>
      
        <content type="html"><![CDATA[<h2 id="浅谈浏览器与node中的事件循环"><a href="#浅谈浏览器与node中的事件循环" class="headerlink" title="浅谈浏览器与node中的事件循环"></a>浅谈浏览器与node中的事件循环</h2><p>  学习node，总结记录一下两者区别</p><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>先从概念说起:</p><ul><li><p>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位)</p></li><li><p>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</p></li></ul><p>举个栗子</p><pre><code>进程就好比一个工厂，它有独立的资源和空间工厂之间是相互独立的线程就是工厂下面的员工一个工厂可以有很多员工员工之间可以共享资源</code></pre><p>进一步</p><pre><code>- 工厂的资源 -&gt; 系统分配的内存（独立的一块内存）- 工厂之间的相互独立 -&gt; 进程之间相互独立- 多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务- 工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成- 工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等)</code></pre><h3 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h3><ul><li>浏览器是多进程的</li><li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li><li>简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。</li></ul><p>在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了 （所以每一个Tab标签对应一个进程并不一定是绝对的）</p><h3 id="浏览器有哪些进程"><a href="#浏览器有哪些进程" class="headerlink" title="浏览器有哪些进程"></a>浏览器有哪些进程</h3><ol><li><p>Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有:</p><ul><li><p>负责浏览器界面显示，与用户交互。如前进，后退等</p></li><li><p>负责各个页面的管理，创建和销毁其他进程</p></li><li><p>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上</p></li><li><p>网络资源的管理，下载等</p></li></ul></li><li><p>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</p></li><li><p>GPU进程：最多一个，用于3D绘制等</p></li><li><p>浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为面渲染，脚本执行，事件处理等</p></li></ol><h3 id="重点：浏览器渲染进程"><a href="#重点：浏览器渲染进程" class="headerlink" title="重点：浏览器渲染进程"></a>重点：浏览器渲染进程</h3><p>1.GUI渲染线程</p><ul><li><p>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</p></li><li><p>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</p></li><li><p>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p></li></ul><p>2.JS引擎线程</p><ul><li><p>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎)</p></li><li><p>JS引擎线程负责解析Javascript脚本，运行代码。</p></li><li><p>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</p></li><li><p>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p></li></ul><p>3.事件触发线程</p><ul><li><p>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</p></li><li><p>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</p></li><li><p>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</p></li><li><p>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</p></li></ul><p>4.定时触发器线程</p><ul><li><p>传说中的setInterval与setTimeout所在线程</p></li><li><p>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确</p></li><li><p>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</p></li><li><p>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</p></li></ul><p>5.异步http请求线程</p><ul><li><p>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</p></li><li><p>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</p></li></ul><p><img src="/2020/10/26/loop/2084336019-5a65972413011_articlex.png" alt="图一"></p><h3 id="WebWorker，JS的多线程"><a href="#WebWorker，JS的多线程" class="headerlink" title="WebWorker，JS的多线程"></a>WebWorker，JS的多线程</h3><ul><li><p>创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</p></li><li><p>JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</p></li></ul><p>如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，<br>只待计算出结果后，将结果通信给主线程即可，perfect!</p><p>JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p><h3 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h3><p>为了简化理解，前期工作直接省略成：(下一篇在记录，输入一个url发生了什么)</p><p>浏览器输入url，浏览器主进程接管，开一个下载线程，<br>然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，<br>随后将内容通过RendererHost接口转交给Renderer进程</p><p>浏览器渲染流程开始</p><p>浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：</p><p>  1.浏览器解析HTML构建DOM树<br>  2.解析CSS 构建render树(讲css代码解析成css树，然后和dom合并成render树)<br>  3.布局render树（Layout/reflow），负责各元素尺寸、位置的计算<br>  4.绘制render树（paint），绘制页面像素信息<br>  5.浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</p><p>  渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了</p><h4 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后</h4><ul><li><p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。<br>(譬如如果有async加载的脚本就不一定完成)</p></li><li><p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。（渲染完毕了）</p></li></ul><p>所以，顺序是：DOMContentLoaded -&gt; load</p><h4 id="css加载是否会阻塞dom树渲染"><a href="#css加载是否会阻塞dom树渲染" class="headerlink" title="css加载是否会阻塞dom树渲染"></a>css加载是否会阻塞dom树渲染</h4><p>css加载不会阻塞DOM树解析,但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</p><h5 id="硬件加速时请使用index"><a href="#硬件加速时请使用index" class="headerlink" title="硬件加速时请使用index"></a>硬件加速时请使用index</h5><p>使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染<br>简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意</p><h3 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h3><p>首先</p><ul><li>JS分为同步任务和异步任务</li><li>同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件</li><li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li></ul><p>上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在,Promise里有了一个一个新的概念：microtask</p><p>进一步，JS中异步队列分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask可称为task,宏任务队列可以有多个，微任务队列只有一个。</p><h4 id="Micro-Task-与-Macro-Task"><a href="#Micro-Task-与-Macro-Task" class="headerlink" title="Micro-Task 与 Macro-Task"></a>Micro-Task 与 Macro-Task</h4><ul><li>macrotask又称之为宏任务,每次执行栈执行的代码就是一个宏任务<ul><li>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染</li></ul></li></ul><p>（<code>task-&gt;渲染-&gt;task-&gt;...</code>）</p><ul><li><p>microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务</p><ul><li>在当前task任务后，下一个task之前，在渲染之前</li><li>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等</li><li>在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）</li></ul></li></ul><h5 id="会形成macrotask和microtask的场景"><a href="#会形成macrotask和microtask的场景" class="headerlink" title="会形成macrotask和microtask的场景"></a>会形成macrotask和microtask的场景</h5><ul><li><p>常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等</p></li><li><p>常见的 micro-task 比如: process.nextTick、new Promise().then(回调)、MutationObserver(html5 新特性) 等。</p><p><strong>异步的实现方式有哪些喃</strong></p><ul><li><p>ES6之前：callback、eventloop</p></li><li><p>ES6：Generator Promise</p></li><li><p>ES7:Async/Await</p><p>Promise中的异步体现在then和catch中，所以写在Promise中的代码是被当做同步任务立即执行的</p><p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体</p><p>await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码。</p></li></ul></li></ul><p>总结下运行机制</p><ul><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li><li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li></ul><p>另外，请注意下Promise的polyfill与官方版本的区别：</p><ul><li>官方版本中，是标准的microtask形式</li><li>polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式<br>请特别注意这两点区别</li></ul><p>注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了），<br>但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准)</p><h3 id="Node-中的-Event-Loop"><a href="#Node-中的-Event-Loop" class="headerlink" title="Node 中的 Event Loop"></a>Node 中的 Event Loop</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js 采用 V8 作为 js 的解析引擎，而 I/O 处理方面使用了自己设计的 libuv，libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 API，事件循环机制也是它里面的实现。<br><img src="/2020/10/26/loop/2019-01-14-004.png" alt="图二"></p><p>Node.js 的运行机制如下:</p><ul><li>V8 引擎解析 JavaScript 脚本。</li><li>解析后的代码，调用 Node API。</li><li>libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。</li><li>V8 引擎再将结果返回给用户。</li></ul><h4 id="六个阶段"><a href="#六个阶段" class="headerlink" title="六个阶段"></a>六个阶段</h4><p>libuv 引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。<br><img src="/2020/10/26/loop/2019-01-14-005.png" alt="图二"></p><p>从上图中，大致看出 node 中的事件循环的顺序：</p><p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O 事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段（按照该顺序反复运行）…</p><ul><li>timers 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调</li><li>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li><li>idle, prepare 阶段：仅 node 内部使用</li><li>poll 阶段：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里</li><li>check 阶段：执行 setImmediate() 的回调</li><li>close callbacks 阶段：执行 socket 的 close 事件回调</li></ul><p>注意：上面六个阶段都不包括 process.nextTick()(下文会介绍)</p><p>我们详细介绍timers、poll、check这 3 个阶段，因为日常开发中的绝大部分异步任务都是在这 3 个阶段处理的。<br><strong>在进入第一次循环之前，会先进行如下操作(会初始化事件循环)</strong></p><ul><li>同步任务</li><li>发出异步请求</li><li>规划定时器生效的时间</li><li>执行process.nextTick()</li></ul><h5 id="1-timer"><a href="#1-timer" class="headerlink" title="1.timer"></a>1.timer</h5><p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。<br>同样，<strong>在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。</strong></p><h5 id="2-poll-轮询"><a href="#2-poll-轮询" class="headerlink" title="2. poll 轮询"></a>2. poll 轮询</h5><p>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p><ul><li>回到 timer 阶段执行回调</li><li>执行 I/O 回调</li></ul><p>并且在进入该阶段时如果没有设定 timer 的话，会发生以下两件事情:</p><ul><li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li><li>如果 poll 队列为空时，会有两件事发生<ul><li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li><li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li></ul></li></ul><p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer ，如果有的话会回到 timer 阶段执行回调。</p><h5 id="3-check-阶段"><a href="#3-check-阶段" class="headerlink" title="3.check 阶段"></a>3.check 阶段</h5><p>setImmediate()的回调会被加入 check 队列中，从 event loop 的阶段图可以知道，check 阶段的执行顺序在 poll 阶段之后</p><pre><code>console.log('start')setTimeout(() =&gt; {  console.log('timer1')  Promise.resolve().then(function() {    console.log('promise1')  })}, 0)setTimeout(() =&gt; {  console.log('timer2')  Promise.resolve().then(function() {    console.log('promise2')  })}, 0)Promise.resolve().then(function() {  console.log('promise3')})console.log('end')//start=&gt;end=&gt;promise3=&gt;timer1=&gt;timer2=&gt;promise1=&gt;promise2</code></pre><ul><li>一开始执行栈的同步任务（这属于宏任务）执行完毕后（依次打印出 start end，并将 2 个 timer 依次放入 timer 队列）,会先去执行微任务（这点跟浏览器端的一样），所以打印出 promise3</li><li>然后进入 timers 阶段，执行 timer1 的回调函数，打印 timer1，并将 promise.then 回调放入 microtask 队列，同样的步骤执行 timer2，打印 timer2；这点跟浏览器端相差比较大，timers 阶段有几个 setTimeout/setInterval 都会依次执行，并不像浏览器端，每执行一个宏任务后就去执行一个微任务（关于 Node 与浏览器的 Event Loop 差异，下文还会详细介绍）。</li></ul><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><h5 id="1-setTimeout-和-setImmediate"><a href="#1-setTimeout-和-setImmediate" class="headerlink" title="1.setTimeout 和 setImmediate"></a>1.setTimeout 和 setImmediate</h5><p>二者非常相似，区别主要在于调用时机不同</p><ul><li><p>setImmediate 设计在 poll 阶段完成时执行，即 check 阶段；</p></li><li><p>setTimeout 设计在 poll 阶段为空闲时，且设定时间到达后执行，但它在 timer 阶段执行</p><pre><code>setTimeout(function timeout () { console.log('timeout');},0);setImmediate(function immediate () { console.log('immediate');});</code></pre></li><li><p>对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。</p></li><li><p>首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的<br>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调</p></li><li><p>如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了</p></li><li><p><em>但当二者在异步 i/o callback 内部调用时，总是先执行 setImmediate，再执行 setTimeout*</em></p><pre><code> const fs = require('fs') fs.readFile(__filename, () =&gt; {   setTimeout(() =&gt; {     console.log('timeout');   }, 0)   setImmediate(() =&gt; {     console.log('immediate')   }) }) // immediate // timeout</code></pre></li></ul><h5 id="2-process-nextTick"><a href="#2-process-nextTick" class="headerlink" title="2.process.nextTick"></a>2.process.nextTick</h5><p>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p><pre><code>setTimeout(() =&gt; {  console.log('timer1')  Promise.resolve().then(function() {  console.log('promise1')  })}, 0)process.nextTick(() =&gt; {    console.log('nextTick')    process.nextTick(() =&gt; {        console.log('nextTick')        process.nextTick(() =&gt; {            console.log('nextTick')                process.nextTick(() =&gt; {                    console.log('nextTick')                })        })    })})// nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>浏览器和 Node 环境下，microtask 任务队列的执行时机不同</p><ul><li>Node 端，microtask 在事件循环的各个阶段之间执行,在各个阶段，当前阶段的宏任务都执行完才会执行当前阶段的微任务</li><li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 事件循环 </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setTimeout 和 setInterval 的区别及相互模拟</title>
      <link href="/2020/10/23/time/"/>
      <url>/2020/10/23/time/</url>
      
        <content type="html"><![CDATA[<p>setTimeout 和 setInterval 的区别及相互模拟<br>最近在复习 node的事件循环和浏览器的事件循环，突然想起setTimeout 和 setInterval 特此记录一下</p><h2 id="一、setTimeout-和-setInterval的区别"><a href="#一、setTimeout-和-setInterval的区别" class="headerlink" title="一、setTimeout 和 setInterval的区别"></a>一、setTimeout 和 setInterval的区别</h2><h3 id="setTimeout-定义和用法"><a href="#setTimeout-定义和用法" class="headerlink" title="setTimeout() 定义和用法"></a>setTimeout() 定义和用法</h3><p>定义：setTimeout()方法用于在指定毫秒数后再调用函数或者计算表达式（以毫秒为单位）返回的 ID 值可用作 清除clearTimeout() 方法的参数<br>语法：</p><pre><code>setTimeout(fn,ms)</code></pre><p>fn：必需，要调用的函数后要执行的函数；ms：必需，在执行代码前需等待的毫秒数。<br>setTimeout() 只执行函数一次，如果需要多次调用可以使用 setInterval()，或者在函数体内再次调用setTimeout()</p><h3 id="setInterval-定义和用法"><a href="#setInterval-定义和用法" class="headerlink" title="setInterval() 定义和用法"></a>setInterval() 定义和用法</h3><p>定义：setInterval() 方法用于按照指定的周期（以毫秒计）来循环调用函数或计算表达式，直到 clearInterval() 被调用或窗口关闭 返回的 ID 值可用作 清除clearTimeout() 方法的参数<br>语法：</p><pre><code>setInterval(fn,ms)</code></pre><p>fn：必需，要调用的函数后要执行的函数；ms：必需，在执行代码前需等待的毫秒数。<br>setInterval() 会不停的调用函数，直到clearInterval() 被调用或者窗口被关闭，由 setInterval() 返回的ID值可用作 clearInterval() 方法的参数。</p><h2 id="二、setInterval缺点"><a href="#二、setInterval缺点" class="headerlink" title="二、setInterval缺点"></a>二、setInterval缺点</h2><p>定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，取决于何时被主线程的事件循环取到，并执行</p><pre><code>setInterval(function, N)  //即：每隔N秒把function事件推到消息队列中</code></pre><p>使用setInterval()的问题在于，定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿</p><p><img src="/2020/10/23/time/31691-20200730104425601-510760599.png" alt="图一"></p><p>上图可见，setInterval每隔100ms往队列中添加一个事件；100ms后，添加T1定时器代码至队列中，主线程中还有任务在执行，所以等待，some event执行结束后执行T1定时器代码；又过了100ms，T2定时器被添加到队列中，主线程还在执行T1代码，所以等待；又过了100ms，理论上又要往队列里推一个定时器代码，但由于此时T2还在队列中，所以T3不会被添加，结果就是此时被跳过；这里我们可以看到，T1定时器执行结束后马上执行了T2代码，所以并没有达到定时器的效果,而是连续执行。</p><p>因此，js引擎对这个问题的解决方法就是，当使用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。</p><p>但是，这样就会导致一些间隔被跳过了，例如上面所讲的，这里依旧有1个间隔被跳过了。如果功能需求是必须要每个定时器的回调函数都有被执行到，这里就不能满足需求了。</p><p>综上所述，setInterval有两个缺点：</p><p>  1.使用setInterval时，某些间隔会被跳过；即使setInterval调用的方法报错了，他仍然会继续执行。<br>  2.无视网络延迟，可能多个定时器会连续执行；</p><p>因而我们一般用 setTimeout 模拟 setInterval，来规避掉上面的缺点。</p><pre><code>setTimeout(function () {  // 任务  setTimeout(arguments.callee, 1000);}, 1000)</code></pre><p>每次函数执行的时候都会创建一个新的定时器。第二个setTimeout()调用当前执行的函数，并为其设置另外一个定时器。这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> setTimeout </tag>
            
            <tag> setInterval </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的节流与去抖</title>
      <link href="/2020/07/22/dene/"/>
      <url>/2020/07/22/dene/</url>
      
        <content type="html"><![CDATA[<p>优化高频率执行js代码的一种手段，js中的一些事件如浏览器的resize、scroll，鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。</p><h2 id="什么是函数节流与函数防抖"><a href="#什么是函数节流与函数防抖" class="headerlink" title="什么是函数节流与函数防抖"></a>什么是函数节流与函数防抖</h2><p>在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。</p><p>通常这种情况下我们怎么去解决的呢？一般来讲，防抖和节流是比较好的解决方案。</p><p>让我们先来看看在事件持续触发的过程中频繁执行函数是怎样的一种情况。</p><p>html 文件中代码如下</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"content"</span> style<span class="token operator">=</span><span class="token string">"height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;"</span><span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">let</span> num <span class="token operator">=</span> 1<span class="token punctuation">;</span>    <span class="token keyword">let</span> content <span class="token operator">=</span> document.getElementById<span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> count<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        content.innerHTML <span class="token operator">=</span> num++<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    content.onmousemove <span class="token operator">=</span> count<span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>在上述代码中，div 元素绑定了 mousemove 事件，当鼠标在 div（灰色）区域中移动的时候会持续地去触发该事件导致频繁执行函数。效果如下<br><img src="/2020/07/22/dene/4842858-652a8eb5c73db0c7.webp" alt="img"></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 节流 </tag>
            
            <tag> 去抖 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
